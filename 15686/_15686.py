# -*- coding: utf-8 -*-
"""# 15686

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/171l7A30Q714MX6CvV3clvf_48h3YxWxu
"""

# 15686 치킨 배달
# N(도시의 한 변의 길이), M(치킨집 최대 수)
import itertools
import sys
N, M = (map(int, input().split()))
city = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] # N*N 크기의 도시를 입력받는다.

# 거리를 구하기 위해 집과 치킨집의 좌표를 리스트에 담는다.
home = [] # 집의 좌표를 담을 리스트
bhc = [] # 치킨 집을 담을 리스트 이름은 임의로 설정 ㅋㅋ..

for i in range(N):
    for j in range(N):
        if city[i][j] == 1: 
            home.append((i+1, j+1)) # 문제에서 좌표가 0 이 아닌 1부터 시작하기 때문에 +1
        elif city[i][j] == 2:
            bhc.append((i+1, j+1))

# 최대 M개의 치킨집 중 도시의 치킨 거리 구하기 !
# 치킨집이 제일 많은 경우중 하나가 도시의 치킨 거리가 가장 적을 수 밖에 없다.
survived_bhc = itertools.combinations(bhc, M) # 치킨집 중 M개만이 폐업을 면할 수 있다.
minimum = sys.maxsize

for bhcs in survived_bhc:
    sum = 0
    for i in home:
            sum += min([ abs(i[0]-j[0]) + abs(i[1]-j[1]) for j in bhcs ])
            if minimum < sum: # 거리의 최소값보다 값이 커지면 더 확인하는 의미가 없다.
                break;
    minimum = min(minimum,sum)
print(minimum)